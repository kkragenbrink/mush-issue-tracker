#
# Loki's Issue Tracker
# For new installations
# 

think [repeat(=, 78)]%r%r[center(ansi(h,Setting up Loki's Issue Tracker v0.9.0), 78)]%r%r[repeat(=, 78)]
-

@set me=QUIET
-

think [ansi(h, ISSUES:)] Checking current installation.
-

#
# Try to find Issues Global.
#

@switch 
    isdbref(setr(0, 
        switch(
            first(version()),
            PennMUSH,lsearch(all,eobjects,\[strmatch(name(##), %[LIT%] Loki's Issue Tracker)\]),
            RhostMUSH,searchng(object=%[LIT%] Loki's Issue Tracker),
            search(object=%[LIT%] Loki's Issue Tracker)
        )
    )) = 
    1, {
        think [ansi(h, ISSUES:)] Current installation found. Updating.;
        &ISS`GLOBAL %#=%q0;
        &ISS`CATEGORY_PARENT %#=[get(%q0/VC)];
    }, {
        think [ansi(h, ISSUES:)] No previous installation found. Installing.;
        &ISS`GLOBAL %#=[create(\[LIT\] Loki's Issue Tracker,10)];
        &DATA`TABLE_PREFIX [v(ISS`GLOBAL)]=lit_;
        &ISS`CATEGORY_PARENT %#=[create(\[LIT\] Loki's Issue Category Parent,10)];
        @tel [v(ISS`CATEGORY_PARENT)]=[v(ISS`GLOBAL)];
        @VC [v(ISS`GLOBAL)]=[v(ISS`CATEGORY_PARENT)];
        &ACCESS [v(ISS`CATEGORY_PARENT)]=1;
    }
-

#
# Tables
#

think [ansi(h, ISSUES:)] Configuring MySQL Tables.
-

@wait 0= 
{
    @assert sql(SELECT 1) = {think [ansi(h, ISSUES:)] ERROR - Unable to reach MySQL database. This installation will be incomplete.};
    @assert get(v(ISS`GLOBAL)/VERSION) =
    {
        think [ansi(h, ISSUES:)] Creating new tables.;
        think setq(0, get(v(ISS`GLOBAL)/DATA`TABLE_PREFIX));
        think sql(lit(
            CREATE TABLE `%q0issue`
            (
                `id` INT(11) UNSIGNED AUTO_INCREMENT,
                `title` VARCHAR(30) NOT NULL,
                `category` CHAR(5) NOT NULL,
                `owner` CHAR(10) NOT NULL,
                `status` CHAR(10) NOT NULL,
                `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                `due_at` TIMESTAMP,

                PRIMARY KEY (`id`),
                INDEX (`title`(10)),
                INDEX (`category`),
                INDEX (`owner`),
                INDEX (`status`)
            )
        ));

        think sql(lit(
            CREATE TABLE `%q0issue_note`
            (
                `id` INT(11) UNSIGNED AUTO_INCREMENT,
                `issue_id` INT(11) UNSIGNED,
                `author` CHAR(10) NOT NULL,
                `note` TINYTEXT NOT NULL,
                `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                `deleted_at` TIMESTAMP,

                PRIMARY KEY (`id`),
                INDEX (`issue_id`),
                INDEX (`author`)
            )
        ));

        think sql(lit(
            CREATE TABLE `%q0issue_member`
            (
                `id` INT(11) UNSIGNED AUTO_INCREMENT,
                `issue_id` INT(11) UNSIGNED,
                `member` CHAR(10) NOT NULL,
                
                PRIMARY KEY (`id`),
                INDEX (`issue_id`),
                INDEX (`member`)
            )
        ));
    };
}
-

#
# Commands
#

think [ansi(h, ISSUES:)] Setting up commands.
-

@adisconnect [v(ISS`GLOBAL)]=
    @pemit me=[ifelse(u(FUNCTION`IS_USER, %#), set(%#, LAST_CONN:[secs()]),)]
-

@aconnect [v(ISS`GLOBAL)]=
    @assert default(%#/ISS`LOGIN,1);
    @assert u(FUNCTION`IS_USER, %#);
    @force %#=+issues/new;
-

&COMMAND`CATEGORY/CREATE [v(ISS`GLOBAL)]=
$+category/create *=*:
    @assert u(FUNCTION`IS_SYSOP, %#) = {@pemit %#=Permission denied.};
    think setq(0, trim(secure(%0)));
    think setq(1, trim(secure(%1)));
    @break isdbref(u(FUNCTION`FIND_CATEGORY, %q0)) = {@pemit %#=There is already a category by that name.};
    @assert lte(strlen(%q0), 5) = {@pemit %#=The name of a category is limited to five letters.};
    think setq(2, create(ucstr(%q0), 10));
    @tel %q2=%vC;
    @parent %q2=%vC;
    @desc %q2=%q1;
    @set %q2=inherit !safe !halted !no_command;
    @lock/speech %q2=ACCESS/1;
    @pemit %#=You have created a category named [name(%q2)]. Be sure to change %q0/ACCESS to establish who can access the category. Presently, it is set to the default, which means that anyone who can access +issues can access the category.;
-

@switch [first(version())]=
    PennMUSH,{
        @edit [v(ISS`GLOBAL)]/COMMAND`CATEGORY/CREATE=inherit !safe !halted,wizard !safe !halt
    },
    TinyMUSH,{
        @edit [v(ISS`GLOBAL)]/COMMAND`CATEGORY/CREATE=!no_command,commands
    }
-

&COMMAND`CATEGORY/DELETE [v(ISS`GLOBAL)]=
$+category/delete *=*:
    @assert u(FUNCTION`IS_SYSOP, %#) = {@pemit %#=Permission denied.};
    think setq(0, trim(secure(%0)));
    @assert isdbref(setr(1, u(FUNCTION`FIND_CATEGORY, %q0))) = {@pemit %#=You must specify a valid category to delete.};
    think setq(2, trim(secure(%1)));
    @assert isdbref(setr(3, u(FUNCTION`FIND_CATEGORY, %q2))) = {@pemit %#=You must specify a valid category to transfer active issues to.};
    think setq(4, name(%q1));
    @set %q1=DESTROY_OK;
    @nuke %q1;
    think sql(u(QUERY`UPDATE_ISSUES, `bucket`="%q3", WHERE `bucket` = "%q1"));
    @pemit %#=You have deleted the category named %q4 and transferred all issues to [name(%q3)].;
-

&COMMAND`CATEGORIES [v(ISS`GLOBAL)]=
$+categories:
    @assert u(FUNCTION`IS_USER)={@pemit %#=Permission denied.};
    @pemit %#=u(FUNCTION`HEADER, Categories);
    think setq(0, sortby(%!/SORT`BY_NAME, lcon(%vC)));
    @pemit %#=u(VIEW`CATEGORY_LIST_HEADER);
    @pemit %#=iter(%q0, u(VIEW`CATEGORY_LIST, ##), %b, %r);
    @pemit %#=u(FUNCTION`FOOTER);
-

&COMMAND`ISSUE [v(ISS`GLOBAL)]=
$+issue *=*:
    @assert u(FUNCTION`IS_USER)={@pemit %#=Permission denied.};
    think setq(0, secure(%0));
    think setq(1, edit(objeval(%#, %1), ", &quot;));
    think sql(u(QUERY`CREATE_ISSUE, `title`="%0"\, `category`="[v(DATA`DEFAULT_CATEGORY)]"\, `status`="[v(DATA`DEFAULT_STATUS)]"));
    think setq(2, sql(u(QUERY`LAST_INSERT_ID)));
    think sql(u(QUERY`CREATE_ISSUE_NOTE, `issue_id`=%q2\, `author`="%#"\, `note`="%q1"));
    think sql(u(QUERY`CREATE_ISSUE_MEMBER, `issue_id`=%q2\, `member`="%#"));
    @pemit %#=u(FUNCTION`PREFIX) You have submitted a new issue #%q2: %q0.
-

&COMMAND`ISSUES [v(ISS`GLOBAL)]=
$+issues:
    @assert u(FUNCTION`IS_USER)={@pemit %#=Permission denied.};
    think setq(0, u(FUNCTION`GET_VISIBLE_ISSUES));
    @pemit %#=u(FUNCTION`HEADER, Issues);
    @pemit %#=u(VIEW`ISSUE_LIST_HEADER);
    @pemit %#=iter(%q0, u(VIEW`ISSUE_LIST, ##), %b, %r);
    @pemit %#=u(FUNCTION`FOOTER);
-

#
# Functions
#

think [ansi(h, ISSUES:)] Setting up functions.
-

&FUNCTION`FIND_CATEGORY [v(ISS`GLOBAL)]=
    localize(ifelse(
        or(
            strmatch(name(setr(0,locate(%vC,%0,iT))),%0),
            strmatch(%q0,%0)
        ),
        %q0,
        #-1
    ))
-

&FUNCTION`FOOTER [v(ISS`GLOBAL)]=
    repeat(=, 78)
-

&FUNCTION`GET_VISIBLE_ISSUES [v(ISS`GLOBAL)]=
    ifelse(
        u(FUNCTION`IS_ADMIN, %#),
        sql(u(QUERY`SELECT_ISSUES_BY_CATEGORY, filter(FUNCTION`HAS_ACCESS, lcon(%qC), %b, %b, %#,))),
        sql(u(QUERY`SELECT_ISSUES_BY_MEMBER, %#))
    )
-

&FUNCTION`HEADER [v(ISS`GLOBAL)]=
    center(%b[ansi(h,%0)]%b, 78, =)
-

&FUNCTION`IS_USER [v(ISS`GLOBAL)]=
    not(switch(
        first(version()),
        RhostMUSH, eq(bittype(%0), 0),
        haspower(%0, GUEST)
    ))
-

&FUNCTION`IS_ADMIN [v(ISS`GLOBAL)]=
    hasflag(%0, STAFF)
-

&FUNCTION`IS_SYSOP [v(ISS`GLOBAL)]=
    switch(
        first(version()),
        RhostMUSH, gte(bittype(%0), 5),
        hasflag(%0, WIZARD)
    )
-

&FUNCTION`PREFIX [v(ISS`GLOBAL)]=
    ansi(h, Issues:)
-

&FUNCTION`HAS_ACCESS [v(ISS`GLOBAL)]=
    elock(%0/ACCESS, %1)
-

&SORT`BY_NAME [v(ISS`GLOBAL)]=
    comp(name(%0),name(%1))
-

#
# Queries
#
think [ansi(h, ISSUES:)] Setting up queries.
-

&QUERY`COUNT_ISSUES [v(ISS`GLOBAL)]=
    SELECT COUNT(id) AS `count` 
    FROM `[v(DATA`TABLE_PREFIX)]issue`
    %1
-

&QUERY`CREATE_ISSUE [v(ISS`GLOBAL)]=
    INSERT INTO `[v(DATA`TABLE_PREFIX)]issue`
    SET %0
-

&QUERY`CREATE_ISSUE_MEMBER [v(ISS`GLOBAL)]=
    INSERT INTO `[v(DATA`TABLE_PREFIX)]issue_member`
    SET %0
-

&QUERY`CREATE_ISSUE_NOTE [v(ISS`GLOBAL)]=
    INSERT INTO `[v(DATA`TABLE_PREFIX)]issue_note`
    SET %0
-

&QUERY`LAST_INSERT_ID [v(ISS`GLOBAL)]=
    SELECT last_insert_id()
-

&QUERY`SELECT_ISSUES_BY_CATEGORY [v(ISS`GLOBAL)]=
    SELECT `id`
    FROM `[v(DATA`TABLE_PREFIX)]issue`
    WHERE `category`="%0"
-

&QUERY`SELECT_ISSUES_BY_MEMBER [v(ISS`GLOBAL)]=
    SELECT `[v(DATA`TABLE_PREFIX)]issue`.`id`
    FROM `[v(DATA`TABLE_PREFIX)]issue`
    JOIN `[v(DATA`TABLE_PREFIX)]issue_member`
    WHERE `[v(DATA`TABLE_PREFIX)]issue_member`.`member`="%0"
-

QUERY`SELECT_ISSUE [v(ISS`GLOBAL)]=
    SELECT `id`,`title`,`category`,`owner`,`status`,UNIX_TIMESTAMP(`created_at`),UNIX_TIMESTAMP(`due_at`)
    FROM `[v(DATA`TABLE_PREFIX)]issue`
    %1
-

&QUERY`UPDATE_ISSUES [v(ISS`GLOBAL)]=
    UPDATE  `[v(DATA`TABLE_PREFIX)]issue` 
    SET %0 
    %1
-


#
# Views
#
think [ansi(h, ISSUES:)] Setting up views.
-

&VIEW`CATEGORY_LIST_HEADER [v(ISS`GLOBAL)]=
    [ansi(h,
        Category [ljust(Description, 45)] Access Issues Overdue
    )]%r
    [repeat(-, 78)]
-

&VIEW`CATEGORY_LIST [v(ISS`GLOBAL)]=
    [ljust(name(%0), 9)]
    [ljust(left(get(%0/DESC), 45), 46)]
    [ljust(ifelse(elock(%0/SPEECH, %#), Yes, No), 7)]
    [center(sql(u(QUERY`COUNT_ISSUES, WHERE `category` = "%0")), 7)]
    [center(sql(u(QUERY`COUNT_ISSUES, WHERE `category` = "%0" AND `due_at` <= NOW\(\))), 8)]
-

&VIEW`ISSUE_LIST_HEADER [v(ISS`GLOBAL)]=
    [ansi(h,
        [ljust(#, 5)]
        [ljust(Cat, 6)]
        [ljust(Title, 30)]
        [ljust(Owner, 16)]
        [ljust(Status, 11)]
        [ljust(Due, 10)]
    )]
-

&VIEW`ISSUE_LIST [v(ISS`GLOBAL)]=
    [setq(0, sql(u(QUERY`SELECT_ISSUE, WHERE `id`=%0),|))]
    [ljust(%0, 5)]
    [ljust(name(elements(%q0,3,|)), 6)]
    [ljust(left(elements(%q0,2,|),29),30)]
    [ljust(left(name(elements(%q0,4,|)),15),16)]
    [ljust(elements(%q0,5,|),11)]
    [ljust(elements(convsecs(elements(%q0,7,|)), 3 2 5),10)]
-

#
# Finalizing
#

think [ansi(h, ISSUES:)] Finalizing installation.
-

&VERSION [v(ISS`GLOBAL)]=0.1.0
-

@set me=!quiet
-

think [ansi(h, ISSUES:)] Done.
-